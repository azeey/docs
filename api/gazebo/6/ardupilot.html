<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Gazebo">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Gazebo: $title</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Gazebo</h1>
        <h2>API Reference</h2>
        <div class="version">
        6.16.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 IgnCreateDocs.cmake -->
      <nav class="ign-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.8.17 -->
</div><!-- top -->
<div class="PageDoc"><div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md106"></a>
Case study: migrating the ArduPilot ModelPlugin from Gazebo classic to Ignition Gazebo</h1>
<p>A variety of changes are required when migrating a plugin from Gazebo classic to Ignition Gazebo. In this tutorial we offer as a case study the migration of one particular <code>ModelPlugin</code>, <a href="https://github.com/khancyr/ardupilot_gazebo">ardupilot_gazebo</a>. We hope that this example provides useful tips to others who are migrating their existing plugins from classic to Ignition.</p>
<p>The complete, migrated version of the <code>ardupilot_gazebo</code> plugin covered in this tutorial can be found in <a href="https://github.com/gerkey/ardupilot_gazebo/tree/ignition">this fork</a>.</p>
<h2><a class="anchor" id="autotoc_md107"></a>
Background</h2>
<p>The <code>ardupilot_gazebo</code> plugin is used with Gazebo to assist with simulating unmanned aerial vehicles (UAVs, aka drones). For more information on how to use it, check the <a href="https://ardupilot.org/dev/docs/using-gazebo-simulator-with-sitl.html">ArduPilot documentation</a>.</p>
<p>As context to understand what we're migrating, here's a system diagram for how the ArduPilot Gazebo plugin works is used:</p>
<p><img src="https://raw.githubusercontent.com/gazebosim/gz-sim/main/tutorials/files/ardupilot_diagram.png" alt="" class="inline"/></p>
<p><em>UAV icon credit: By Julian Herzog, CC BY 4.0, <a href="https://commons.wikimedia.org/w/index.php?curid=60965475">https://commons.wikimedia.org/w/index.php?curid=60965475</a></em></p>
<p>For each UAV model in simulation, there is one instance of ArduPilotPlugin loaded into the simulation process. That plugin uses internal simulation APIs to retrieve the UAV's current state, which it sends to an external ArduPilot process via a custom UDP protocol (it's called Flight Dynamics Model, or FDM). The ArduPilot process in turn makes the vehicle state available via the MAVLink protocol to other processes, such as QGroundControl (QGC). The user can issue commands in QGC like "take off" or "goto waypoint", which are sent via MAVLink to ArduPilot, which computes motor commands and sends them to the plugin, which passes them onto the vehicle via internal simulation APIs.</p>
<p>To be clear, this structure is pre-existing and widely used in UAV simulation. Our contribution in this tutorial is port the plugin from Gazebo to Ignition, preserving the rest of the setup.</p>
<h2><a class="anchor" id="autotoc_md108"></a>
Structure of the migration</h2>
<p>Migration of this plugin involves modifications to multiple parts of the associated code:</p>
<ol type="1">
<li>The plugin header file, <code>ArduPilotPlugin.hh</code></li>
<li>The plugin source file, <code>ArduPilotPlugin.cc</code></li>
<li>The plugin's CMake build recipe, <code>CMakeLists.txt</code></li>
<li>The custom model in which the plugin is used</li>
</ol>
<p>We'll take them each in turn in the following sections.</p>
<h2><a class="anchor" id="autotoc_md109"></a>
Plugin header file (ArduPilotPlugin.hh)</h2>
<h3><a class="anchor" id="autotoc_md110"></a>
Headers</h3>
<p>The old code includes these Gazebo classic headers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/common.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/physics/physics.hh&gt;</span></div>
</div><!-- fragment --><p>In the new code, we still need <code>&lt;sdf/sdf.hh&gt;</code>, because the underlying <a href="http://sdformat.org/">SDFormat library</a> is used by both classic and Ignition. But in place of the <code>&lt;gazebo/...&gt;</code> headers, we'll pull in one from Ignition:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2System_8hh.html">gz/sim/System.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md111"></a>
Class declaration</h3>
<p>In the old code, the plugin class <code>ArduPilotPlugin</code> is declared in the <code>gazebo</code> namespace: </p><div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">namespace </span>sim</div>
<div class="line">{</div>
</div><!-- fragment --><p>In the new code we declare the class in the <code>gz::sim::systems</code> namespace:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">namespace </span><a class="code" href="namespacegz.html">gz</a></div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>sim</div>
<div class="line">{</div>
<div class="line"><span class="keyword">namespace </span>systems</div>
<div class="line">{</div>
</div><!-- fragment --><p>In the old code, the plugin class inherits from <code>ModelPlugin</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">class </span>GAZEBO_VISIBLE ArduPilotPlugin : <span class="keyword">public</span> ModelPlugin</div>
</div><!-- fragment --><p>In the new code, we use multiple inheritance to declare that our plugin will act as a <em>system</em> (in the entity-component-system, or ECS, pattern used by Ignition), and further which interfaces of a system it will use (we also update the symbol visibility macro):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">class </span>IGNITION_GAZEBO_VISIBLE ArduPilotPlugin:</div>
<div class="line">       <span class="keyword">public</span> <a class="code" href="classignition_1_1gazebo_1_1System.html">gz::sim::System</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code" href="classignition_1_1gazebo_1_1ISystemConfigure.html">gz::sim::ISystemConfigure</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code" href="classignition_1_1gazebo_1_1ISystemPostUpdate.html">gz::sim::ISystemPostUpdate</a>,</div>
<div class="line">       <span class="keyword">public</span> <a class="code" href="classignition_1_1gazebo_1_1ISystemPreUpdate.html">gz::sim::ISystemPreUpdate</a></div>
</div><!-- fragment --><p>With this declaration we're indicating that our plugin will supply implementation of the <code>Configure()</code>, <code>PreUpdate()</code>, and <code>PostUpdate()</code> methods.</p>
<p>In the old code, the <code>Load()</code> method is called once for each instance of the plugin that is loaded, allowing for startup configuration, like pulling parameters out of the plugin's SDF configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> Load(physics::ModelPtr _model, sdf::ElementPtr _sdf);</div>
</div><!-- fragment --><p>In the new code, we use <code>Configure()</code> for the same purpose (if a different signature):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> Configure(<span class="keyword">const</span> <a class="code" href="namespaceignition_1_1gazebo.html#ad83694d867b0e3a9446b535b5dfd208d">gz::sim::Entity</a> &amp;_entity,</div>
<div class="line">  <span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr&lt;const sdf::Element&gt;</a> &amp;_sdf,</div>
<div class="line">  <a class="code" href="classignition_1_1gazebo_1_1EntityComponentManager.html">gz::sim::EntityComponentManager</a> &amp;_ecm,</div>
<div class="line">  <a class="code" href="classignition_1_1gazebo_1_1EventManager.html">gz::sim::EventManager</a> &amp;_eventMgr);</div>
</div><!-- fragment --><p>Similarly, the old code provides <code>OnUpdate()</code>, which is called once per time step while simulation is running:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keywordtype">void</span> OnUpdate();</div>
</div><!-- fragment --><p>In the new code, this method is replaced by two methods, <code>PreUpdate()</code> and <code>PostUpdate()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> PreUpdate(<span class="keyword">const</span> <a class="code" href="structignition_1_1gazebo_1_1UpdateInfo.html">gz::sim::UpdateInfo</a> &amp;_info,</div>
<div class="line">  <a class="code" href="classignition_1_1gazebo_1_1EntityComponentManager.html">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> PostUpdate(<span class="keyword">const</span> <a class="code" href="structignition_1_1gazebo_1_1UpdateInfo.html">gz::sim::UpdateInfo</a> &amp;_info,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classignition_1_1gazebo_1_1EntityComponentManager.html">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
</div><!-- fragment --><p>As the names suggest, the former is called before each time step, while the latter is called after each time step. Note the subtle difference in signature: <code>PreUpdate()</code> takes a non-<code>const</code> reference to the <code>EntityComponentManager</code>, while <code>PostUpdate()</code> takes a <code>const</code> reference to it. We'll make any changes to the state of simulation (e.g., setting torques on joints) in <code>PreUpdate()</code> and we'll read out results from simulation (e.g., getting the pose of a link) in <code>PostUpdate()</code>.</p>
<p>The remaining changes in the header are just bookkeeping, to allow us to have access to the right objects with the right types in other class methods. These three helpers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keywordtype">void</span> ApplyMotorForces(<span class="keyword">const</span> <span class="keywordtype">double</span> _dt);</div>
<div class="line"><span class="keywordtype">void</span> SendState();</div>
<div class="line"><span class="keywordtype">bool</span> InitArduPilotSockets(sdf::ElementPtr _sdf);</div>
</div><!-- fragment --><p>become:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> ApplyMotorForces(<span class="keyword">const</span> <span class="keywordtype">double</span> _dt,</div>
<div class="line">  <a class="code" href="classignition_1_1gazebo_1_1EntityComponentManager.html">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"><span class="keywordtype">void</span> SendState(<span class="keywordtype">double</span> _simTime,</div>
<div class="line">  <span class="keyword">const</span> <a class="code" href="classignition_1_1gazebo_1_1EntityComponentManager.html">gz::sim::EntityComponentManager</a> &amp;_ecm);</div>
<div class="line"><span class="keywordtype">bool</span> InitArduPilotSockets(<span class="keyword">const</span> <a class="codeRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr&lt;const sdf::Element&gt;</a> &amp;_sdf);</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md112"></a>
Plugin source file (ArduPilotPlugin.cc)</h2>
<h3><a class="anchor" id="autotoc_md113"></a>
Headers</h3>
<p>The old code includes these Gazebo-related headers:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/math/Filter.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/Assert.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/common/Plugin.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/msgs/msgs.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/sensors/sensors.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gazebo/transport/transport.hh&gt;</span></div>
</div><!-- fragment --><p>Like we did in <code>ArduPilotPlugin.hh</code>, we'll keep <code>&lt;sdf/sdf.hh&gt;</code>. The others are replaced with Ignition equivalents, and where possible we narrow the inclusion to exactly what we need. We start by enumerating those <em>components</em> (part of the ECS pattern used by Ignition) that we're using:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2AngularVelocity_8hh.html">gz/sim/components/AngularVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2gz_2sim_2components_2Imu_8hh.html">gz/sim/components/Imu.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2JointForceCmd_8hh.html">gz/sim/components/JointForceCmd.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2JointPosition_8hh.html">gz/sim/components/JointPosition.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2JointVelocity_8hh.html">gz/sim/components/JointVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2JointVelocityCmd_8hh.html">gz/sim/components/JointVelocityCmd.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2LinearVelocity_8hh.html">gz/sim/components/LinearVelocity.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2Name_8hh.html">gz/sim/components/Name.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2components_2Pose_8hh.html">gz/sim/components/Pose.hh</a>&gt;</span></div>
</div><!-- fragment --><p>To better understand the ECS pattern as it is used in Ignition, it's helpful to learn about the EntityComponentManager (ECM), which is responsible for managing the ECS graph. A great resource to understand the logic under the hood of the ECM is the <code>SdfEntityCreator</code> class (<a href="https://github.com/gazebosim/gz-sim/blob/main/include/ignition/gazebo/SdfEntityCreator.hh">header</a>, <a href="https://github.com/gazebosim/gz-sim/blob/main/src/SdfEntityCreator.cc">source</a>). This class is responsible for mapping the content of an SDF file to the entities and components that form the graph handled by the ECM. For example, if you wonder which components can be accessed by default from the plugin, this class is the best entry point.</p>
<p>Next we include the parts of <code>ign-gazebo</code> itself that we're using:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2Model_8hh.html">gz/sim/Model.hh</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="gz_2sim_2Util_8hh.html">gz/sim/Util.hh</a>&gt;</span></div>
</div><!-- fragment --><p>We need a few things from <code>ign-math</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/math/Helpers.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/math/Pose3.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/math/PID.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/math/Vector3.hh&gt;</span></div>
</div><!-- fragment --><p>To use the <code><a class="elRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#abcee184a421558b5599b4bdd075bf61b">IGNITION_ADD_PLUGIN()</a></code> and <code><a class="elRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#a1eabf3749f038a9224fb1ec16e090087">IGNITION_ADD_PLUGIN_ALIAS()</a></code> macros, we need a header from <code>ign-plugin</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/plugin/Register.hh&gt;</span></div>
</div><!-- fragment --><p>Because we'll be subscribing to data published by a sensor, we need a header from <code>ign-transport</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;gz/transport/Node.hh&gt;</span></div>
</div><!-- fragment --><p>And we keep the SDFormat header:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="preprocessor">#include &lt;sdf/sdf.hh&gt;</span></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md114"></a>
Class members</h3>
<p>Now let's get into the class member declarations. The <code>PID</code> class has moved from <code>common</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">common::PID pid;</div>
</div><!-- fragment --><p>to <code>gz::math</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">gz::math::PID pid;</div>
</div><!-- fragment --><p>In the old code we store a <code>physics::JointPtr</code> for each propeller joint we're controlling:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">physics::JointPtr joint;</div>
</div><!-- fragment --><p>In the new code we store an <code>gz::sim::Entity</code> instead:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code" href="namespaceignition_1_1gazebo.html#ad83694d867b0e3a9446b535b5dfd208d">gz::sim::Entity</a> joint;</div>
</div><!-- fragment --><p>In the old code we store an <code>event::ConnectionPtr</code> to manage periodic calls to the <code>OnUpdate()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">event::ConnectionPtr updateConnection;</div>
</div><!-- fragment --><p>There's no equivalent class member in the new code. Instead we declared our intent to have this class's update methods called via its inheritance.</p>
<p>In the old code we store a <code>physics::ModelPtr</code> for the model we're acting on:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">physics::ModelPtr model;</div>
</div><!-- fragment --><p>In the new code we instead store references to the model, the entity underlying the model, and the entity underyling one of the links in the model:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="code" href="namespaceignition_1_1gazebo.html#ad83694d867b0e3a9446b535b5dfd208d">gz::sim::Entity</a> entity{<a class="code" href="namespaceignition_1_1gazebo.html#a03d78dd6f322345283506c2005476e79">gz::sim::kNullEntity</a>};</div>
<div class="line"><a class="code" href="classignition_1_1gazebo_1_1Model.html">gz::sim::Model</a> model{<a class="code" href="namespaceignition_1_1gazebo.html#a03d78dd6f322345283506c2005476e79">gz::sim::kNullEntity</a>};</div>
<div class="line"><a class="code" href="namespaceignition_1_1gazebo.html#ad83694d867b0e3a9446b535b5dfd208d">gz::sim::Entity</a> modelLink{<a class="code" href="namespaceignition_1_1gazebo.html#a03d78dd6f322345283506c2005476e79">gz::sim::kNullEntity</a>};</div>
</div><!-- fragment --><p>The old code uses a custom time class:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">sim::common::Time lastControllerUpdateTime;</div>
</div><!-- fragment --><p>while the new code uses <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd_1_1chrono.html">std::chrono</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">std::chrono::steady_clock::duration lastControllerUpdateTime{0};</div>
</div><!-- fragment --><p>In this plugin we need to read data from an IMU sensor attached to the UAV. In the old code we store a pointer to the sensor:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">sensors::ImuSensorPtr imuSensor;</div>
</div><!-- fragment --><p>In the new code, instead of accessing the sensor object directly we must subscribe to a topic published by the sensor (you might be tempted to try retrieving the sensor data via components attached to the IMU entity, but that won't work because the logic to produce the data lives in the IMU system and its output can only be consumed via subscription). So we need a few more variables to track the state of subscription, data receipt via subscription, and so on:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> imuName;</div>
<div class="line"><span class="keywordtype">bool</span> imuInitialized;</div>
<div class="line">gz::transport::Node node;</div>
<div class="line">gz::msgs::IMU imuMsg;</div>
<div class="line"><span class="keywordtype">bool</span> imuMsgValid;</div>
<div class="line"><a class="codeRef" href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a> imuMsgMutex;</div>
</div><!-- fragment --><p>We also need a callback function that will be invoked upon receipt of newly published data from the IMU sensor. The callback just latches the latest message in a mutex-controlled fashion:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordtype">void</span> imuCb(<span class="keyword">const</span> gz::msgs::IMU &amp;_msg)</div>
<div class="line">{</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/thread/lock_guard.html">std::lock_guard&lt;std::mutex&gt;</a> <a class="codeRef" href="http://en.cppreference.com/w/cpp/thread/lock.html">lock</a>(this-&gt;imuMsgMutex);</div>
<div class="line">  imuMsg = _msg;</div>
<div class="line">  imuMsgValid = <span class="keyword">true</span>;</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md115"></a>
Console logging</h3>
<p>Throughout the code, we replace the following output streams from the old code:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">gzdbg &lt;&lt; ... ;</div>
<div class="line">gzlog &lt;&lt; ... ;</div>
<div class="line">gzwarn &lt;&lt; ... ;</div>
<div class="line">gzerr &lt;&lt; ... ;</div>
</div><!-- fragment --><p>with their Ignition equivalents:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#acc94b8f20a0596b68b4ec266a75fa8be">igndbg</a> &lt;&lt; ... ;</div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#a4650b956b09bfa86be5770c1cfa522ae">ignlog</a> &lt;&lt; ... ;</div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#a27f74932032badfe1255e584f1e8a791">ignwarn</a> &lt;&lt; ... ;</div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#ab2bfcd13bf44fe6d8c2f19c530c10e28">ignerr</a> &lt;&lt; ... ;</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md116"></a>
Plugin interface: Configure()</h3>
<p>Recall that <code>Configure()</code> replaces <code>Load()</code>.</p>
<p>In the old code, we store the model pointer and name:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">this-&gt;dataPtr-&gt;model = _model;</div>
<div class="line">this-&gt;dataPtr-&gt;modelName = this-&gt;dataPtr-&gt;model-&gt;GetName();</div>
</div><!-- fragment --><p>In the new code, we store the entity, model, and name a bit differently:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">this-&gt;dataPtr-&gt;entity = _entity;</div>
<div class="line">this-&gt;dataPtr-&gt;model = <a class="code" href="namespaceignition_1_1gazebo_1_1components.html#a81c45336dd134e03c5a29b34beb293db">gz::sim::Model</a>(_entity);</div>
<div class="line">this-&gt;dataPtr-&gt;modelName = this-&gt;dataPtr-&gt;model.Name(_ecm);</div>
</div><!-- fragment --><p>Also in the new code we need to make sure of the existence of the specific <em>components</em> that we need. In our case, we're going to access the <code>WorldPose</code> and <code>WorldLinearVelocity</code> components of the <em>entity</em> representing one of the UAV model's links. The data in those components will be periodically updated by the physics <em>system</em>. But the physics system will not necessarily create the components, so before accessing them later in our code, we need to ensure that the components exist:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span>(!_ecm.EntityHasComponentType(this-&gt;dataPtr-&gt;modelLink, components::WorldPose::typeId))</div>
<div class="line">{</div>
<div class="line">  _ecm.CreateComponent(this-&gt;dataPtr-&gt;modelLink, gz::sim::components::WorldPose());</div>
<div class="line">}</div>
<div class="line"><span class="keywordflow">if</span>(!_ecm.EntityHasComponentType(this-&gt;dataPtr-&gt;modelLink, components::WorldLinearVelocity::typeId))</div>
<div class="line">{</div>
<div class="line">  _ecm.CreateComponent(this-&gt;dataPtr-&gt;modelLink, gz::sim::components::WorldLinearVelocity());</div>
<div class="line">}</div>
</div><!-- fragment --><p>We'll see this pattern elsewhere in the new code: check for a component's existence, create it if necessary, then proceed with using it.</p>
<p>We also clone the <code>const sdf::Element</code> that we've passed so that we can call non-<code>const</code> methods on it:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">sdf::ElementPtr sdfClone = _sdf-&gt;Clone();</div>
</div><!-- fragment --><p>In the old code we retrieve a pointer to each joint that we're controlling:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">control.joint = _model-&gt;GetJoint(control.jointName);</div>
</div><!-- fragment --><p>In the new code we retrieve the entity that represents the joint:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">control.joint = this-&gt;dataPtr-&gt;model.JointByName(_ecm, control.jointName);</div>
</div><!-- fragment --><p>The accessor methods for members in the <code>PID</code> class have changed. The old code uses a <code>Get</code> prefix, e.g.:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_p_gain&quot;</span>, control.pid.GetPGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_i_gain&quot;</span>, control.pid.GetIGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_d_gain&quot;</span>, control.pid.GetDGain()).first;</div>
</div><!-- fragment --><p>In the new code, the <code>Get</code> prefix is gone:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_p_gain&quot;</span>, control.pid.PGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_i_gain&quot;</span>, control.pid.IGain()).first;</div>
<div class="line">param = controlSDF-&gt;Get(<span class="stringliteral">&quot;vel_d_gain&quot;</span>, control.pid.DGain()).first;</div>
</div><!-- fragment --><p>The old code does a bunch of lookups to get a pointer to the IMU sensor. In the new code, we just store the name of the sensors from the user-supplied SDF configuration:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">this-&gt;dataPtr-&gt;imuName = _sdf-&gt;Get(<span class="stringliteral">&quot;imuName&quot;</span>, <span class="keyword">static_cast&lt;</span><a class="codeRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a><span class="keyword">&gt;</span>(<span class="stringliteral">&quot;imu_sensor&quot;</span>)).first;</div>
</div><!-- fragment --><p>and we do the equivalent lookup later, in <code>PreUpdate()</code>, which we'll cover next.</p>
<h3><a class="anchor" id="autotoc_md117"></a>
Plugin interface: OnUpdate() -&gt; PreUpdate() + PostUpdate()</h3>
<p>The old code does the following each time step in its <code>OnUpdate()</code> method:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> sim::common::Time curTime =</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;GetWorld()-&gt;SimTime();</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (curTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  this-&gt;ReceiveMotorCommand();</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;ApplyMotorForces((curTime -</div>
<div class="line">      this-&gt;dataPtr-&gt;lastControllerUpdateTime).Double());</div>
<div class="line">    this-&gt;SendState();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">this-&gt;dataPtr-&gt;lastControllerUpdateTime = curTime;</div>
</div><!-- fragment --><p>As mentioned above, in the new code we're splitting that work into two halves: the "write" part should happen in <code>PreUpdate()</code> and the "read" part should happen in <code>PostUpdate()</code>.</p>
<p>In <code>PreUpdate()</code> we receive new commands from the external ArduPilot process and write the resulting forces to propeller joints in simulation:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span> (_info.simTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  this-&gt;ReceiveMotorCommand();</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;ApplyMotorForces(<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast.html">std::chrono::duration_cast</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration&lt;double&gt;</a> &gt;(_info.simTime -</div>
<div class="line">      this-&gt;dataPtr-&gt;lastControllerUpdateTime).<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration/count.html">count</a>(), _ecm);</div>
<div class="line">  }</div>
</div><!-- fragment --><p>Then in <code>PostUpdate()</code> we read the latest state (e.g., IMU sensor data, UAV pose and velocity) from simulation and send it out to ArduPilot:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span> (_info.simTime &gt; this-&gt;dataPtr-&gt;lastControllerUpdateTime)</div>
<div class="line">{</div>
<div class="line">  <span class="keywordflow">if</span> (this-&gt;dataPtr-&gt;arduPilotOnline)</div>
<div class="line">  {</div>
<div class="line">    this-&gt;SendState(<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast.html">std::chrono::duration_cast</a>&lt;<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration&lt;double&gt;</a> &gt;(_info.simTime).<a class="codeRef" href="http://en.cppreference.com/w/cpp/chrono/duration/count.html">count</a>(),</div>
<div class="line">            _ecm);</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">this-&gt;dataPtr-&gt;lastControllerUpdateTime = _info.simTime;</div>
</div><!-- fragment --><p>Note the differences in both methods with regard to time-handling: (i) the current simulation time is passed in as part of an <code>gz::sim::UpdateInfo</code> object; and (ii) we operate on time values using <code><a class="elRef" href="http://en.cppreference.com/w/namespacestd_1_1chrono.html">std::chrono</a></code>.</p>
<h4><a class="anchor" id="autotoc_md118"></a>
One-time initialization in PreUpdate(): subscribing to sensor data</h4>
<p>Though it's not part of the regular update loop, we subscribe to the IMU sensor data in <code>PreUpdate()</code> because the information that we need for that subscription isn't available when we're in <code>Configure()</code>.</p>
<p>That one-time subscription logic looks like this, starting with determination of the right topic name and ending with registering our previously defined <code>imuCb()</code> method as the callback to receive new IMU data:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keywordflow">if</span>(!this-&gt;dataPtr-&gt;imuInitialized)</div>
<div class="line">{</div>
<div class="line">  <span class="comment">// Set unconditionally because we&#39;re only going to try this once.</span></div>
<div class="line">  this-&gt;dataPtr-&gt;imuInitialized = <span class="keyword">true</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keyword">auto</span> imuEntity = _ecm.EntityByComponents(</div>
<div class="line">      <a class="code" href="namespaceignition_1_1gazebo_1_1components.html#a501c2b6aeb7302e017055ef1a442faab">components::Name</a>(this-&gt;dataPtr-&gt;imuName),</div>
<div class="line">      <a class="code" href="namespaceignition_1_1gazebo_1_1components.html#a5b54cafbb965ca861020b90d5ccf7e2a">components::Imu</a>(),</div>
<div class="line">      <a class="code" href="namespaceignition_1_1gazebo_1_1components.html#a6e4fc60b44eb0e0cf7fdfee1f1b93b86">components::ParentEntity</a>(this-&gt;dataPtr-&gt;modelLink));</div>
<div class="line">  <span class="keyword">auto</span> imuTopicName = _ecm.ComponentData&lt;components::SensorTopic&gt;(imuEntity);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span>(imuTopicName.empty())</div>
<div class="line">  {</div>
<div class="line">    <a class="codeRef" href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#ab2bfcd13bf44fe6d8c2f19c530c10e28">ignerr</a> &lt;&lt; <span class="stringliteral">&quot;[&quot;</span> &lt;&lt; this-&gt;dataPtr-&gt;modelName &lt;&lt; <span class="stringliteral">&quot;] &quot;</span></div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;imu_sensor [&quot;</span> &lt;&lt; this-&gt;dataPtr-&gt;imuName</div>
<div class="line">          &lt;&lt; <span class="stringliteral">&quot;] not found, abort ArduPilot plugin.&quot;</span> &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  this-&gt;dataPtr-&gt;node.Subscribe(imuTopicName, &amp;gz::sim::systems::ArduPilotPluginPrivate::imuCb, this-&gt;dataPtr.get());</div>
<div class="line">}</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md119"></a>
Writing to simulation</h3>
<p>Based on commands received from ArduPilot, new forces are applied to the propeller joints in <code>ApplyMotorForces()</code>, using the joints' current velocities as feedback. In the old code that's done by calling <code>GetVelocity()</code> and <code>SetForce()</code> on each joint <code>i</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> vel = this-&gt;dataPtr-&gt;controls[i].joint-&gt;GetVelocity(0);</div>
<div class="line"><span class="comment">// ...do some feedback control math to compute force from vel...</span></div>
<div class="line">this-&gt;dataPtr-&gt;controls[i].joint-&gt;SetForce(0, force);</div>
</div><!-- fragment --><p>In the new code, for each joint <code>i</code> we read from the <code>JointVelocity</code> component attached to the corresponding entity, and we write to the <code>JointForceCmd</code> component attached to the same entity (creating it first in case it doesn't yet exist):</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> vel = _ecm.ComponentData&lt;<a class="code" href="namespaceignition_1_1gazebo_1_1components.html#a64427335ab235cc2ce07461b343f6eb3">gz::sim::components::JointVelocity</a>&gt;(</div>
<div class="line">    this-&gt;dataPtr-&gt;controls[i].joint);</div>
<div class="line"><span class="comment">// ...do some feedback control math to compute force from vel...</span></div>
<div class="line">_ecm.SetComponentData(this-&gt;dataPtr-&gt;controls[i].joint,</div>
<div class="line">    <a class="code" href="namespaceignition_1_1gazebo_1_1components.html#acb1fa80d3ae07408b4bd1efbeedaef15">gz::sim::components::JointForceCmd</a>({force}));</div>
</div><!-- fragment --><p>A similar pattern is used for the case of setting a velocity on a joint; instead of calling <code>SetVelocity()</code> on the joint, we write to the <code>JointVelocityCmd</code> component of the joint entity.</p>
<h3><a class="anchor" id="autotoc_md120"></a>
Reading from simulation</h3>
<p>To prepare the data that will be sent to ArduPilot, in <code>SendState()</code> we need to read some information from simulation, specifically: linear acceleration and angular velocity from the IMU, and the UAV's pose and linear velocity in the world frame.</p>
<p>In the old code, we get the IMU data by calling methods on the sensor object and copying the result into the packet that we're going to send to ArduPilot:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> gz::math::Vector3d linearAccel =</div>
<div class="line">  this-&gt;dataPtr-&gt;imuSensor-&gt;LinearAcceleration();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[0] = linearAccel.X();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[1] = linearAccel.Y();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[2] = linearAccel.Z();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> gz::math::Vector3d angularVel =</div>
<div class="line">  this-&gt;dataPtr-&gt;imuSensor-&gt;AngularVelocity();</div>
<div class="line">pkt.imuAngularVelocityRPY[0] = angularVel.X();</div>
<div class="line">pkt.imuAngularVelocityRPY[1] = angularVel.Y();</div>
<div class="line">pkt.imuAngularVelocityRPY[2] = angularVel.Z();</div>
</div><!-- fragment --><p>In the new code, as previously mentioned, these data are accessed by subscribing to the sensor via ign-transport. In that subscription we registered a callback that just copies the latest IMU message to <code>imuMsg</code> and sets the flag <code>imuMsgValid</code>, using <code>imuMsgMutex</code> to exclude concurrent access to those variables. So we access the latest IMU sensor by copying and reading from that message:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line">gz::msgs::IMU imuMsg;</div>
<div class="line">{</div>
<div class="line">  <a class="codeRef" href="http://en.cppreference.com/w/cpp/thread/lock_guard.html">std::lock_guard&lt;std::mutex&gt;</a> <a class="codeRef" href="http://en.cppreference.com/w/cpp/thread/lock.html">lock</a>(this-&gt;dataPtr-&gt;imuMsgMutex);</div>
<div class="line">  <span class="keywordflow">if</span>(!this-&gt;dataPtr-&gt;imuMsgValid)</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span>;</div>
<div class="line">  }</div>
<div class="line">  imuMsg = this-&gt;dataPtr-&gt;imuMsg;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">pkt.imuLinearAccelerationXYZ[0] = imuMsg.linear_acceleration().x();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[1] = imuMsg.linear_acceleration().y();</div>
<div class="line">pkt.imuLinearAccelerationXYZ[2] = imuMsg.linear_acceleration().z();</div>
<div class="line"> </div>
<div class="line">pkt.imuAngularVelocityRPY[0] = imuMsg.angular_velocity().x();</div>
<div class="line">pkt.imuAngularVelocityRPY[1] = imuMsg.angular_velocity().y();</div>
<div class="line">pkt.imuAngularVelocityRPY[2] = imuMsg.angular_velocity().z();</div>
</div><!-- fragment --><p>In the old code, we access the UAV's pose linear velocity in the world frame by calling <code>WorldPose()</code> and <code>WorldLinearVelocity()</code>, respectively, on the model object:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line"><span class="keyword">const</span> gz::math::Pose3d gazeboXYZToModelXForwardZDown =</div>
<div class="line">  this-&gt;modelXYZToAirplaneXForwardZDown +</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;WorldPose();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> gz::math::Vector3d velGazeboWorldFrame =</div>
<div class="line">  this-&gt;dataPtr-&gt;model-&gt;GetLink()-&gt;WorldLinearVel();</div>
</div><!-- fragment --><p>In the new code we instead read from the <code>WorldPose</code> and <code>WorldLinearVelocity</code> components attached to the entity representing one of the UAV model's links:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><span class="keyword">const</span> gz::sim::components::WorldPose* pComp =</div>
<div class="line">    _ecm.Component&lt;gz::sim::components::WorldPose&gt;(this-&gt;dataPtr-&gt;modelLink);</div>
<div class="line"><span class="keyword">const</span> gz::math::Pose3d gazeboXYZToModelXForwardZDown =</div>
<div class="line">  this-&gt;modelXYZToAirplaneXForwardZDown +</div>
<div class="line">  pComp-&gt;Data();</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> gz::sim::components::WorldLinearVelocity* vComp =</div>
<div class="line">  _ecm.Component&lt;gz::sim::components::WorldLinearVelocity&gt;(this-&gt;dataPtr-&gt;modelLink);</div>
<div class="line"><span class="keyword">const</span> gz::math::Vector3d velGazeboWorldFrame = vComp-&gt;Data();</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md121"></a>
Registering the plugin</h3>
<p>In the old code we register our plugin via the macro <code>GZ_REGISTER_PLUGIN()</code>:</p>
<div class="fragment"><div class="line"><span class="comment">// OLD</span></div>
<div class="line">GZ_REGISTER_MODEL_PLUGIN(ArduPilotPlugin)</div>
</div><!-- fragment --><p>In the new code we instead use two macros: <code><a class="elRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#abcee184a421558b5599b4bdd075bf61b">IGNITION_ADD_PLUGIN()</a></code> and <code><a class="elRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#a1eabf3749f038a9224fb1ec16e090087">IGNITION_ADD_PLUGIN_ALIAS()</a></code>:</p>
<div class="fragment"><div class="line"><span class="comment">// NEW</span></div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#abcee184a421558b5599b4bdd075bf61b">IGNITION_ADD_PLUGIN</a>(gz::sim::systems::ArduPilotPlugin,</div>
<div class="line">                    <a class="code" href="classignition_1_1gazebo_1_1System.html">gz::sim::System</a>,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemConfigure,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemPostUpdate,</div>
<div class="line">                    gz::sim::systems::ArduPilotPlugin::ISystemPreUpdate)</div>
<div class="line"><a class="codeRef" href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#a1eabf3749f038a9224fb1ec16e090087">IGNITION_ADD_PLUGIN_ALIAS</a>(gz::sim::systems::ArduPilotPlugin,<span class="stringliteral">&quot;ArduPilotPlugin&quot;</span>)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md122"></a>
Build recipe: &lt;tt&gt;CMakeLists.txt&lt;/tt&gt;</h2>
<p>Compared to the code changes, the updates in the CMake configuration are pretty minor and primarily result from the fact that the formerly monolithic Gazebo project is now a set of Ignition libraries.</p>
<p>In the old code we retrieve all the required build configuration by finding the Gazebo package:</p>
<div class="fragment"><div class="line"># OLD</div>
<div class="line">find_package(gazebo REQUIRED)</div>
</div><!-- fragment --><p>In the new code we explicitly reference each Ignition package that we use:</p>
<div class="fragment"><div class="line"># NEW</div>
<div class="line">find_package(sdformat12 REQUIRED)</div>
<div class="line">find_package(ignition-common4-all REQUIRED)</div>
<div class="line">find_package(ignition-gazebo6-all REQUIRED)</div>
<div class="line">find_package(ignition-math6-all REQUIRED)</div>
<div class="line">find_package(ignition-msgs8-all REQUIRED)</div>
<div class="line">find_package(ignition-physics5-all REQUIRED)</div>
<div class="line">find_package(ignition-sensors6-all REQUIRED)</div>
<div class="line">find_package(ignition-transport11-all REQUIRED)</div>
</div><!-- fragment --><p>In the old code we need only refer to the build configuration retrieved from the Gazebo package:</p>
<div class="fragment"><div class="line">include_directories(</div>
<div class="line">        ${PROJECT_SOURCE_DIR}</div>
<div class="line">        include</div>
<div class="line">        ${GAZEBO_INCLUDE_DIRS})</div>
<div class="line"> </div>
<div class="line">link_libraries(</div>
<div class="line">        ${GAZEBO_LIBRARIES}</div>
<div class="line">)</div>
</div><!-- fragment --><p>Whereas in the new code we refer to build configuration from each Ignition package:</p>
<div class="fragment"><div class="line">include_directories(</div>
<div class="line">        ${PROJECT_SOURCE_DIR}</div>
<div class="line">        include</div>
<div class="line">        ${SDFORMAT-INCLUDE_DIRS}</div>
<div class="line">        ${IGNITION-COMMON_INCLUDE_DIRS}</div>
<div class="line">        ${IGNITION-GAZEBO_INCLUDE_DIRS}</div>
<div class="line">        ${IGNITION-MATH_INCLUDE_DIRS}</div>
<div class="line">        ${IGNITION-MSGS_INCLUDE_DIRS}</div>
<div class="line">        ${IGNITION-TRANSPORT_INCLUDE_DIRS}</div>
<div class="line">        )</div>
<div class="line"> </div>
<div class="line">link_libraries(</div>
<div class="line">        ${SDFORMAT-LIBRARIES}</div>
<div class="line">        ${IGNITION-COMMON_LIBRARIES}</div>
<div class="line">        ${IGNITION-GAZEBO_LIBRARIES}</div>
<div class="line">        ${IGNITION-MATH_LIBRARIES}</div>
<div class="line">        ${IGNITION-MSGS_LIBRARIES}</div>
<div class="line">        ${IGNITION-TRANSPORT_LIBRARIES}</div>
<div class="line">        )</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md123"></a>
The model</h2>
<p>The old UAV is defined in two parts: (i) the <code>iris_with_standoffs</code> model, which defines the vehicle structure; and (ii) the <code>iris_with_ardupilot</code> model, which includes the extends the <code>iris_with_standoffs</code> model by adding plugins needed to fly it.</p>
<p>Because model inclusion is not (yet?) supported, the new model just combines the additional plugin configuration from <code>iris_with_ardupilot</code> into <code>iris_with_standoffs</code>. Along the way a few changes are made, as follows.</p>
<p>The <code>&lt;script&gt;</code> tag for visual material is not (yet?) supported, so in the model, instances of <code>&lt;script&gt;</code> are just commented out (which leaves the UAV visually untextured, but functional).</p>
<p>In the old model, loading an instance of the LiftDrag plugin for each half of each propeller looks like this:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- OLD --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">    <span class="keyword">name</span>=<span class="stringliteral">&quot;rotor_0_blade_1&quot;</span></div>
<div class="line">    <span class="keyword">filename</span>=<span class="stringliteral">&quot;LiftDragPlugin&quot;</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!-- ...configuration goes here... --&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">link_name</span>&gt;<span class="keyword">iris::rotor_0</span>&lt;/<span class="keywordtype">link_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><p>In the new model, we do this instead:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- NEW --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">    <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::LiftDrag&quot;</span></div>
<div class="line">    <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-lift-drag-system&quot;</span>&gt;</div>
<div class="line">  <span class="comment">&lt;!-- ...configuration goes here... --&gt;</span></div>
<div class="line">  &lt;<span class="keywordtype">link_name</span>&gt;<span class="keyword">rotor_0</span>&lt;/<span class="keywordtype">link_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><p>In the old model, it's possible to read joint state and apply joint forces automatically. In the new model, we must instantiate the <code>JointStatePublisher</code> plugin once for the entire model and the <code>ApplyJointForce</code> plugin once for each propeller joint:</p>
<div class="fragment"><div class="line"><span class="comment">&lt;!-- NEW --&gt;</span></div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-joint-state-publisher-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::JointStatePublisher&quot;</span>&gt;&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_0_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_1_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_2_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
<div class="line">&lt;<span class="keywordtype">plugin</span></div>
<div class="line">  <span class="keyword">filename</span>=<span class="stringliteral">&quot;ignition-gazebo-apply-joint-force-system&quot;</span></div>
<div class="line">  <span class="keyword">name</span>=<span class="stringliteral">&quot;gz::sim::systems::ApplyJointForce&quot;</span>&gt;</div>
<div class="line">  &lt;<span class="keywordtype">joint_name</span>&gt;<span class="keyword">rotor_3_joint</span>&lt;/<span class="keywordtype">joint_name</span>&gt;</div>
<div class="line">&lt;/<span class="keywordtype">plugin</span>&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md124"></a>
What's next</h2>
<p>You should be able to apply the same general changes covered in this tutorial to your Gazebo plugins to migrate them to Ignition.</p>
<p>Check out <a href="https://github.com/gerkey/ardupilot_gazebo/tree/ignition#using-with-ignition">these instructions</a> if you'd like to learn more about using ardupilot_gazebo with Ignition. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="agz_2plugin_2Register_8hh_html_abcee184a421558b5599b4bdd075bf61b"><div class="ttname"><a href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#abcee184a421558b5599b4bdd075bf61b">IGNITION_ADD_PLUGIN</a></div><div class="ttdeci">#define IGNITION_ADD_PLUGIN(PluginClass,...)</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_a5b54cafbb965ca861020b90d5ccf7e2a"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#a5b54cafbb965ca861020b90d5ccf7e2a">ignition::gazebo::components::Imu</a></div><div class="ttdeci">Component&lt; sdf::Sensor, class ImuTag, serializers::SensorSerializer &gt; Imu</div><div class="ttdoc">A component type that contains an IMU sensor, sdf::IMU, information.</div><div class="ttdef"><b>Definition:</b> include/gz/sim/components/Imu.hh:40</div></div>
<div class="ttc" id="alock_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/thread/lock.html">std::lock</a></div><div class="ttdeci">T lock(T... args)</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_html_ad83694d867b0e3a9446b535b5dfd208d"><div class="ttname"><a href="namespaceignition_1_1gazebo.html#ad83694d867b0e3a9446b535b5dfd208d">ignition::gazebo::Entity</a></div><div class="ttdeci">uint64_t Entity</div><div class="ttdoc">An Entity identifies a single object in simulation such as a model, link, or light....</div><div class="ttdef"><b>Definition:</b> gz/sim/Entity.hh:58</div></div>
<div class="ttc" id="abasic_string_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1EntityComponentManager_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1EntityComponentManager.html">ignition::gazebo::EntityComponentManager</a></div><div class="ttdoc">The EntityComponentManager constructs, deletes, and returns components and entities....</div><div class="ttdef"><b>Definition:</b> gz/sim/EntityComponentManager.hh:66</div></div>
<div class="ttc" id="ashared_ptr_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1Model_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1Model.html">ignition::gazebo::Model</a></div><div class="ttdoc">This class provides wrappers around entities and components which are more convenient and straight-fo...</div><div class="ttdef"><b>Definition:</b> gz/sim/Model.hh:60</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_a6e4fc60b44eb0e0cf7fdfee1f1b93b86"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#a6e4fc60b44eb0e0cf7fdfee1f1b93b86">ignition::gazebo::components::ParentEntity</a></div><div class="ttdeci">Component&lt; Entity, class ParentEntityTag &gt; ParentEntity</div><div class="ttdoc">This component holds an entity's parent entity.</div><div class="ttdef"><b>Definition:</b> gz/sim/components/ParentEntity.hh:41</div></div>
<div class="ttc" id="aduration_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/chrono/duration.html">std::chrono::duration</a></div></div>
<div class="ttc" id="agz_2common_2Console_8hh_html_a4650b956b09bfa86be5770c1cfa522ae"><div class="ttname"><a href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#a4650b956b09bfa86be5770c1cfa522ae">ignlog</a></div><div class="ttdeci">#define ignlog</div></div>
<div class="ttc" id="agz_2sim_2components_2JointPosition_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2JointPosition_8hh.html">JointPosition.hh</a></div></div>
<div class="ttc" id="alock_guard_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/thread/lock_guard.html">std::lock_guard</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1EventManager_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1EventManager.html">ignition::gazebo::EventManager</a></div><div class="ttdoc">The EventManager is used to send/receive notifications of simulator events.</div><div class="ttdef"><b>Definition:</b> gz/sim/EventManager.hh:54</div></div>
<div class="ttc" id="agz_2common_2Console_8hh_html_ab2bfcd13bf44fe6d8c2f19c530c10e28"><div class="ttname"><a href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#ab2bfcd13bf44fe6d8c2f19c530c10e28">ignerr</a></div><div class="ttdeci">#define ignerr</div></div>
<div class="ttc" id="agz_2sim_2components_2Name_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2Name_8hh.html">Name.hh</a></div></div>
<div class="ttc" id="agz_2sim_2components_2JointVelocityCmd_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2JointVelocityCmd_8hh.html">JointVelocityCmd.hh</a></div></div>
<div class="ttc" id="agz_2sim_2components_2JointForceCmd_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2JointForceCmd_8hh.html">JointForceCmd.hh</a></div></div>
<div class="ttc" id="agz_2sim_2System_8hh_html"><div class="ttname"><a href="gz_2sim_2System_8hh.html">System.hh</a></div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_acb1fa80d3ae07408b4bd1efbeedaef15"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#acb1fa80d3ae07408b4bd1efbeedaef15">ignition::gazebo::components::JointForceCmd</a></div><div class="ttdeci">Component&lt; std::vector&lt; double &gt;, class JointForceCmdTag &gt; JointForceCmd</div><div class="ttdoc">Commanded joint forces (or torques) to be applied to a joint in SI units (Nm for revolute,...</div><div class="ttdef"><b>Definition:</b> gz/sim/components/JointForceCmd.hh:38</div></div>
<div class="ttc" id="astructignition_1_1gazebo_1_1UpdateInfo_html"><div class="ttname"><a href="structignition_1_1gazebo_1_1UpdateInfo.html">ignition::gazebo::UpdateInfo</a></div><div class="ttdoc">Information passed to systems on the update callback.</div><div class="ttdef"><b>Definition:</b> include/gz/sim/Types.hh:38</div></div>
<div class="ttc" id="agz_2sim_2Model_8hh_html"><div class="ttname"><a href="gz_2sim_2Model_8hh.html">Model.hh</a></div></div>
<div class="ttc" id="agz_2plugin_2Register_8hh_html_a1eabf3749f038a9224fb1ec16e090087"><div class="ttname"><a href="https://gazebosim.org/api/plugin/1/gz_2plugin_2Register_8hh.html#a1eabf3749f038a9224fb1ec16e090087">IGNITION_ADD_PLUGIN_ALIAS</a></div><div class="ttdeci">#define IGNITION_ADD_PLUGIN_ALIAS(PluginClass,...)</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_html_a03d78dd6f322345283506c2005476e79"><div class="ttname"><a href="namespaceignition_1_1gazebo.html#a03d78dd6f322345283506c2005476e79">ignition::gazebo::kNullEntity</a></div><div class="ttdeci">const Entity kNullEntity</div><div class="ttdoc">Indicates a non-existant or invalid Entity.</div><div class="ttdef"><b>Definition:</b> gz/sim/Entity.hh:61</div></div>
<div class="ttc" id="agz_2common_2Console_8hh_html_acc94b8f20a0596b68b4ec266a75fa8be"><div class="ttname"><a href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#acc94b8f20a0596b68b4ec266a75fa8be">igndbg</a></div><div class="ttdeci">#define igndbg</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_a64427335ab235cc2ce07461b343f6eb3"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#a64427335ab235cc2ce07461b343f6eb3">ignition::gazebo::components::JointVelocity</a></div><div class="ttdeci">Component&lt; std::vector&lt; double &gt;, class JointVelocityTag, serializers::VectorDoubleSerializer &gt; JointVelocity</div><div class="ttdoc">Base class which can be extended to add serialization.</div><div class="ttdef"><b>Definition:</b> gz/sim/components/JointVelocity.hh:38</div></div>
<div class="ttc" id="anamespacegz_html"><div class="ttname"><a href="namespacegz.html">gz</a></div></div>
<div class="ttc" id="agz_2common_2Console_8hh_html_a27f74932032badfe1255e584f1e8a791"><div class="ttname"><a href="https://gazebosim.org/api/common/4/gz_2common_2Console_8hh.html#a27f74932032badfe1255e584f1e8a791">ignwarn</a></div><div class="ttdeci">#define ignwarn</div></div>
<div class="ttc" id="agz_2sim_2components_2AngularVelocity_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2AngularVelocity_8hh.html">AngularVelocity.hh</a></div></div>
<div class="ttc" id="ainclude_2gz_2sim_2components_2Imu_8hh_html"><div class="ttname"><a href="include_2gz_2sim_2components_2Imu_8hh.html">Imu.hh</a></div></div>
<div class="ttc" id="agz_2sim_2components_2LinearVelocity_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2LinearVelocity_8hh.html">LinearVelocity.hh</a></div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1ISystemPreUpdate_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1ISystemPreUpdate.html">ignition::gazebo::ISystemPreUpdate</a></div><div class="ttdoc">Interface for a system that uses the PreUpdate phase.</div><div class="ttdef"><b>Definition:</b> gz/sim/System.hh:121</div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1ISystemPostUpdate_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1ISystemPostUpdate.html">ignition::gazebo::ISystemPostUpdate</a></div><div class="ttdoc">Interface for a system that uses the PostUpdate phase.</div><div class="ttdef"><b>Definition:</b> gz/sim/System.hh:135</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_a81c45336dd134e03c5a29b34beb293db"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#a81c45336dd134e03c5a29b34beb293db">ignition::gazebo::components::Model</a></div><div class="ttdeci">Component&lt; NoData, class ModelTag &gt; Model</div><div class="ttdoc">A component that identifies an entity as being a model.</div><div class="ttdef"><b>Definition:</b> gz/sim/components/Model.hh:111</div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1ISystemConfigure_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1ISystemConfigure.html">ignition::gazebo::ISystemConfigure</a></div><div class="ttdoc">Interface for a system that implements optional configuration.</div><div class="ttdef"><b>Definition:</b> gz/sim/System.hh:90</div></div>
<div class="ttc" id="agz_2sim_2Util_8hh_html"><div class="ttname"><a href="gz_2sim_2Util_8hh.html">Util.hh</a></div></div>
<div class="ttc" id="agz_2sim_2components_2JointVelocity_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2JointVelocity_8hh.html">JointVelocity.hh</a></div></div>
<div class="ttc" id="aduration_cast_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/chrono/duration/duration_cast.html">std::chrono::duration_cast</a></div><div class="ttdeci">T duration_cast(T... args)</div></div>
<div class="ttc" id="agz_2sim_2components_2Pose_8hh_html"><div class="ttname"><a href="gz_2sim_2components_2Pose_8hh.html">Pose.hh</a></div></div>
<div class="ttc" id="aclassignition_1_1gazebo_1_1System_html"><div class="ttname"><a href="classignition_1_1gazebo_1_1System.html">ignition::gazebo::System</a></div><div class="ttdoc">Base class for a System.</div><div class="ttdef"><b>Definition:</b> gz/sim/System.hh:75</div></div>
<div class="ttc" id="acount_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/chrono/duration/count.html">std::chrono::duration::count</a></div><div class="ttdeci">T count(T... args)</div></div>
<div class="ttc" id="amutex_html"><div class="ttname"><a href="http://en.cppreference.com/w/cpp/thread/mutex.html">std::mutex</a></div><div class="ttdoc">STL class.</div></div>
<div class="ttc" id="anamespaceignition_1_1gazebo_1_1components_html_a501c2b6aeb7302e017055ef1a442faab"><div class="ttname"><a href="namespaceignition_1_1gazebo_1_1components.html#a501c2b6aeb7302e017055ef1a442faab">ignition::gazebo::components::Name</a></div><div class="ttdeci">Component&lt; std::string, class NameTag, serializers::StringSerializer &gt; Name</div><div class="ttdoc">This component holds an entity's name. The component has no concept of scoped names nor does it care ...</div><div class="ttdef"><b>Definition:</b> gz/sim/components/Name.hh:37</div></div>
      </div>
    </main>
  </div>
</body>
