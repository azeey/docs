<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=9"/>
    <meta name="keywords" content="Gazebo Sim">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Gazebo Sim: Server Class Reference</title>
    <script type="text/javascript" src="https://gazebosim.org/assets/doxygen/dynsections.js"></script>
    <script type="text/javascript" src="jquery.js"></script>
    <link rel="icon" type="image/x-icon" href="https://gazebosim.org/assets/icon/favicon.ico">
    <link href='http://fonts.googleapis.com/css?family=Roboto:400,300,100,500,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons">
    <link rel="stylesheet" href="https://code.getmdl.io/1.3.0/material.deep_orange-blue.min.css">
    <script defer src="https://code.getmdl.io/1.3.0/material.min.js"></script>
    <script type="text/javascript" id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"> </script>
    <link href="https://gazebosim.org/assets/doxygen/doxygen.css" rel="stylesheet" type="text/css">
  </head>
    <script type="text/javascript">
      /* Replace all the "permalink" &#9670;&nbsp; icons with a unicode link
        symbol.*/
      $(document).ready(function() {
        var elems = document.getElementsByClassName("permalink");
        for (var i = 0; i < elems.length; ++i) {
          elems[i].firstChild.innerHTML="&#x1f517;";
          elems[i].firstChild.style.fontSize="18px";
        }
      });
    </script>
  </head>
<body>
  <div class="mdl-layout mdl-js-layout mdl-layout--fixed-drawer">
    <div class="mdl-layout__drawer mdl-color--grey-100 mdl-color-text--blue-grey-50">
      <header class="mdl-color--grey-100">
        <a href="index.html"><img width="60px" src="https://gazebosim.org/assets/doxygen/gazebo_logo.svg"/></a>
        <h1 class="project_title">Gazebo Sim</h1>
        <h2>API Reference</h2>
        <div class="version">
        7.8.0
        </div>
      </header>
      <!-- NOTE: If you add a link to a doxygen generated page, then make
                 sure to update the required_html_fils list in
                 GzCreateDocs.cmake -->
      <nav class="gz-navigation mdl-navigation">
        <a class="mdl-navigation__link" href="tutorials.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Tutorials</a>
        <a id="class_menu" class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">library_books</i>Classes</a>
        <a id="namespaces_menu"class="mdl-navigation__link" href="#">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">toc</i>Namespaces</a>
        <a class="mdl-navigation__link" href="files.html">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">insert_drive_file</i>Files</a>
        <a class="mdl-navigation__link" target="_blank"
           href="http://gazebosim.org">
          <i class="mdl-color-text--grey-400 material-icons"
             role="presentation">launch</i>Gazebo Website</a>
      </nav>
      <!-- classes sub menu -->
      <ul for="class_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link" href="classes.html">Index</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="annotated.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="hierarchy.html">Hierarchy</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions.html">Members: All</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_func.html">Members: Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_vars.html">Members: Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_type.html">Members: Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_enum.html">Members: Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
             href="functions_eval.html">Members: Enumerator</a>
        </li>
      </ul>
      <!-- namespaces sub menu -->
      <ul for="namespaces_menu" class="mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect mdl-navigation">
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespaces.html">List</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers.html">Members</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_func.html">Functions</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_type.html">Typedefs</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_vars.html">Variables</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_enum.html">Enumerations</a>
        </li>
        <li class="mdl-menu__item">
          <a class="mdl-navigation__link"
            href="namespacemembers_eval.html">Enumerator</a>
        </li>
      </ul>
    </div>
    <main class="mdl-layout__content mdl-color--white">
    <div id="top">
<!-- Generated by Doxygen 1.8.17 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacegz.html">gz</a></li><li class="navelem"><a class="el" href="namespacegz_1_1sim.html">sim</a></li><li class="navelem"><a class="el" href="classgz_1_1sim_1_1Server.html">Server</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classgz_1_1sim_1_1Server-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">Server Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>The server instantiates and controls simulation.  
 <a href="classgz_1_1sim_1_1Server.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="gz_2sim_2Server_8hh_source.html">gz/sim/Server.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a084ef7616f5af42061a7aeded5651ab0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a084ef7616f5af42061a7aeded5651ab0">Server</a> (const <a class="el" href="classgz_1_1sim_1_1ServerConfig.html">ServerConfig</a> &amp;_config=<a class="el" href="classgz_1_1sim_1_1ServerConfig.html">ServerConfig</a>())</td></tr>
<tr class="memdesc:a084ef7616f5af42061a7aeded5651ab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct the server using the parameters specified in a <a class="el" href="classgz_1_1sim_1_1ServerConfig.html" title="Configuration parameters for a Server. An instance of this object can be used to construct a Server w...">ServerConfig</a>.  <a href="classgz_1_1sim_1_1Server.html#a084ef7616f5af42061a7aeded5651ab0">More...</a><br /></td></tr>
<tr class="separator:a084ef7616f5af42061a7aeded5651ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9320a8b35b2d116b716ae4077358c6b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#aa9320a8b35b2d116b716ae4077358c6b">~Server</a> ()</td></tr>
<tr class="memdesc:aa9320a8b35b2d116b716ae4077358c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classgz_1_1sim_1_1Server.html#aa9320a8b35b2d116b716ae4077358c6b">More...</a><br /></td></tr>
<tr class="separator:aa9320a8b35b2d116b716ae4077358c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d6bd6e365a6abd2db6b6d6d704fb6"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a576d6bd6e365a6abd2db6b6d6d704fb6">AddSystem</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classgz_1_1sim_1_1System.html">System</a> &gt; &amp;_system, const unsigned int _worldIndex=0)</td></tr>
<tr class="memdesc:a576d6bd6e365a6abd2db6b6d6d704fb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> to the server. The server must not be running when calling this.  <a href="classgz_1_1sim_1_1Server.html#a576d6bd6e365a6abd2db6b6d6d704fb6">More...</a><br /></td></tr>
<tr class="separator:a576d6bd6e365a6abd2db6b6d6d704fb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef95e9bc88b7b608b8d24852ba61bdff"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#aef95e9bc88b7b608b8d24852ba61bdff">AddSystem</a> (const <a class="el" href="namespacegz_1_1sim.html#a3bf4c8bbf313a71ffe6eeaf6abb6a3f8">SystemPluginPtr</a> &amp;_system, const unsigned int _worldIndex=0)</td></tr>
<tr class="memdesc:aef95e9bc88b7b608b8d24852ba61bdff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> to the server. The server must not be running when calling this.  <a href="classgz_1_1sim_1_1Server.html#aef95e9bc88b7b608b8d24852ba61bdff">More...</a><br /></td></tr>
<tr class="separator:aef95e9bc88b7b608b8d24852ba61bdff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657bdb4f186c20844b1d5142cc7b6302"><td class="memItemLeft" align="right" valign="top">std::optional&lt; <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a657bdb4f186c20844b1d5142cc7b6302">EntityByName</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a657bdb4f186c20844b1d5142cc7b6302"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an Entity based on a name.  <a href="classgz_1_1sim_1_1Server.html#a657bdb4f186c20844b1d5142cc7b6302">More...</a><br /></td></tr>
<tr class="separator:a657bdb4f186c20844b1d5142cc7b6302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c36b630054b5c8b6746971070207fd8"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a6c36b630054b5c8b6746971070207fd8">EntityCount</a> (const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a6c36b630054b5c8b6746971070207fd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of entities on the server.  <a href="classgz_1_1sim_1_1Server.html#a6c36b630054b5c8b6746971070207fd8">More...</a><br /></td></tr>
<tr class="separator:a6c36b630054b5c8b6746971070207fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5078ea19560e797e61c7c654d5d49f77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a5078ea19560e797e61c7c654d5d49f77">HasEntity</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a5078ea19560e797e61c7c654d5d49f77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified world has an entity with the provided name.  <a href="classgz_1_1sim_1_1Server.html#a5078ea19560e797e61c7c654d5d49f77">More...</a><br /></td></tr>
<tr class="separator:a5078ea19560e797e61c7c654d5d49f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bac8f6ded4953caf2c28c5d14344f87"><td class="memItemLeft" align="right" valign="top">std::optional&lt; uint64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a5bac8f6ded4953caf2c28c5d14344f87">IterationCount</a> (const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a5bac8f6ded4953caf2c28c5d14344f87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of iterations the server has executed.  <a href="classgz_1_1sim_1_1Server.html#a5bac8f6ded4953caf2c28c5d14344f87">More...</a><br /></td></tr>
<tr class="separator:a5bac8f6ded4953caf2c28c5d14344f87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1516cd041ab3e4beb13e8ff7c45b1655"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655">Paused</a> (const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a1516cd041ab3e4beb13e8ff7c45b1655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether a world simulation instance is paused. When paused is true, then simulation for the world is not stepping forward.  <a href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655">More...</a><br /></td></tr>
<tr class="separator:a1516cd041ab3e4beb13e8ff7c45b1655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ee30ca04a311d697ae23ce772fe948"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a90ee30ca04a311d697ae23ce772fe948">RequestRemoveEntity</a> (const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a> _entity, bool _recursive=true, const unsigned int _worldIndex=0)</td></tr>
<tr class="memdesc:a90ee30ca04a311d697ae23ce772fe948"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified world has an entity with the provided id and the entity was queued for deletion. Note that the entity is not removed immediately. Entity deletion happens at the end of the next (or current depending on when this function is called) simulation step.  <a href="classgz_1_1sim_1_1Server.html#a90ee30ca04a311d697ae23ce772fe948">More...</a><br /></td></tr>
<tr class="separator:a90ee30ca04a311d697ae23ce772fe948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fddfd81ed8c8c790d2acff187ced659"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a0fddfd81ed8c8c790d2acff187ced659">RequestRemoveEntity</a> (const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;_name, bool _recursive=true, const unsigned int _worldIndex=0)</td></tr>
<tr class="memdesc:a0fddfd81ed8c8c790d2acff187ced659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the specified world has an entity with the provided name and the entity was queued for deletion. Note that the entity is not removed immediately. Entity deletion happens at the end of the next (or current depending on when this function is called) simulation step.  <a href="classgz_1_1sim_1_1Server.html#a0fddfd81ed8c8c790d2acff187ced659">More...</a><br /></td></tr>
<tr class="separator:a0fddfd81ed8c8c790d2acff187ced659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf20a9b198865a3d0662c275a80aa526"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#abf20a9b198865a3d0662c275a80aa526">Run</a> (const bool _blocking=false, const uint64_t _iterations=0, const bool _paused=true)</td></tr>
<tr class="memdesc:abf20a9b198865a3d0662c275a80aa526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the server. By default this is a non-blocking call, which means the server runs simulation in a separate thread. Pass in true to the _blocking argument to run the server in the current thread.  <a href="classgz_1_1sim_1_1Server.html#abf20a9b198865a3d0662c275a80aa526">More...</a><br /></td></tr>
<tr class="separator:abf20a9b198865a3d0662c275a80aa526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5c7ae68fbe26852eaf04a7fdc655fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#aac5c7ae68fbe26852eaf04a7fdc655fe">Running</a> () const</td></tr>
<tr class="memdesc:aac5c7ae68fbe26852eaf04a7fdc655fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether the server is running. The server can have zero or more simulation worlds, each of which may or may not be running. See Running(const unsigned int) to get the running status of a world.  <a href="classgz_1_1sim_1_1Server.html#aac5c7ae68fbe26852eaf04a7fdc655fe">More...</a><br /></td></tr>
<tr class="separator:aac5c7ae68fbe26852eaf04a7fdc655fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42e1554323d91c88e6df18655b756420"><td class="memItemLeft" align="right" valign="top">std::optional&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a42e1554323d91c88e6df18655b756420">Running</a> (const unsigned int _worldIndex) const</td></tr>
<tr class="memdesc:a42e1554323d91c88e6df18655b756420"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get whether a world simulation instance is running. When running is true, then systems are being updated but simulation may or may not be stepping forward. Check the value of <a class="el" href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655" title="Get whether a world simulation instance is paused. When paused is true, then simulation for the world...">Paused()</a> to determine if a world simulation instance is stepping forward. If <a class="el" href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655" title="Get whether a world simulation instance is paused. When paused is true, then simulation for the world...">Paused()</a> returns true, then simulation is not stepping foward.  <a href="classgz_1_1sim_1_1Server.html#a42e1554323d91c88e6df18655b756420">More...</a><br /></td></tr>
<tr class="separator:a42e1554323d91c88e6df18655b756420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0eb38158a7e5df85cf81fc3f198370"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a3c0eb38158a7e5df85cf81fc3f198370">RunOnce</a> (const bool _paused=true)</td></tr>
<tr class="memdesc:a3c0eb38158a7e5df85cf81fc3f198370"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the server once, all systems will be updated once and then this returns. This is a blocking call.  <a href="classgz_1_1sim_1_1Server.html#a3c0eb38158a7e5df85cf81fc3f198370">More...</a><br /></td></tr>
<tr class="separator:a3c0eb38158a7e5df85cf81fc3f198370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c9003abeeb903390af28413dc303d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#ac1c9003abeeb903390af28413dc303d5">SetPaused</a> (const bool _paused, const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:ac1c9003abeeb903390af28413dc303d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether a world simulation instance is paused. When paused is true, then simulation for the world is not stepping forward.  <a href="classgz_1_1sim_1_1Server.html#ac1c9003abeeb903390af28413dc303d5">More...</a><br /></td></tr>
<tr class="separator:ac1c9003abeeb903390af28413dc303d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afedf75d17864604847c76f76ae18aa46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#afedf75d17864604847c76f76ae18aa46">SetUpdatePeriod</a> (const std::chrono::steady_clock::duration &amp;_updatePeriod, const unsigned int _worldIndex=0)</td></tr>
<tr class="memdesc:afedf75d17864604847c76f76ae18aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the update period. The update period is the wall-clock time between ECS updates. Note that this is different from the simulation update rate. ECS systems will be updated even while sim time is paused.  <a href="classgz_1_1sim_1_1Server.html#afedf75d17864604847c76f76ae18aa46">More...</a><br /></td></tr>
<tr class="separator:afedf75d17864604847c76f76ae18aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17a237457e57625296e6b24feb19c60a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a17a237457e57625296e6b24feb19c60a">Stop</a> ()</td></tr>
<tr class="memdesc:a17a237457e57625296e6b24feb19c60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the server. This will stop all running simulations.  <a href="classgz_1_1sim_1_1Server.html#a17a237457e57625296e6b24feb19c60a">More...</a><br /></td></tr>
<tr class="separator:a17a237457e57625296e6b24feb19c60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f59172ee2a9c52d30d7e33c93c8046"><td class="memItemLeft" align="right" valign="top">std::optional&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classgz_1_1sim_1_1Server.html#a55f59172ee2a9c52d30d7e33c93c8046">SystemCount</a> (const unsigned int _worldIndex=0) const</td></tr>
<tr class="memdesc:a55f59172ee2a9c52d30d7e33c93c8046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of systems on the server.  <a href="classgz_1_1sim_1_1Server.html#a55f59172ee2a9c52d30d7e33c93c8046">More...</a><br /></td></tr>
<tr class="separator:a55f59172ee2a9c52d30d7e33c93c8046"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The server instantiates and controls simulation. </p>
<h2><a class="anchor" id="autotoc_md359"></a>
Example Usage</h2>
<p>A basic simulation server can be instantiated and run using</p>
<div class="fragment"><div class="line"><a class="code" href="classgz_1_1sim_1_1Server.html#a084ef7616f5af42061a7aeded5651ab0" title="Construct the server using the parameters specified in a ServerConfig.">Server</a> server;</div>
<div class="line">server.Run();</div>
</div><!-- fragment --><p>An SDF File can be passed into the server via a <a class="el" href="classgz_1_1sim_1_1ServerConfig.html" title="Configuration parameters for a Server. An instance of this object can be used to construct a Server w...">ServerConfig</a> object. The server will parse the SDF file and create entities for the elements contained in the file.</p>
<div class="fragment"><div class="line">ServerConfig config;</div>
<div class="line">config.SetSdfFile(<span class="stringliteral">&quot;path_to_file.sdf&quot;</span>);</div>
<div class="line"><a class="code" href="classgz_1_1sim_1_1Server.html#a084ef7616f5af42061a7aeded5651ab0" title="Construct the server using the parameters specified in a ServerConfig.">Server</a> server(config);</div>
<div class="line">server.Run();</div>
</div><!-- fragment --><p>The <a class="el" href="classgz_1_1sim_1_1Server.html#abf20a9b198865a3d0662c275a80aa526" title="Run the server. By default this is a non-blocking call, which means the server runs simulation in a s...">Run()</a> function accepts a few arguments, one of which is whether simulation should start in a paused state. The default value of this argument is true, which starts simulation paused. This means that by default, running the server will cause systems to update but some systems may not update because paused == true. For example, a physics system will not update its state when paused is true. So, while a <a class="el" href="classgz_1_1sim_1_1Server.html" title="The server instantiates and controls simulation.">Server</a> can be Running, simulation itself can be paused.</p>
<p>Simulation is paused by default because a common use case is to load a world from the command line. If simulation starts running, the GUI client may miss the first few simulation iterations.</p>
<h2><a class="anchor" id="autotoc_md360"></a>
Services</h2>
<p>The following are services provided by the <a class="el" href="classgz_1_1sim_1_1Server.html" title="The server instantiates and controls simulation.">Server</a>. The <code>&lt;world_name&gt;</code> in the service list is the name of the simulated world.</p>
<p>List syntax: <em>service_name(request_msg_type) : response_msg_type</em></p>
<ol type="1">
<li><code>/world/&lt;world_name&gt;/scene/info</code>(none) : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1Scene.html">gz::msgs::Scene</a><ul>
<li>Returns the current scene information.</li>
</ul>
</li>
<li><code>/gazebo/resource_paths/get</code>(<a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1Empty.html">gz::msgs::Empty</a>) : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1StringMsg__V.html">gz::msgs::StringMsg_V</a><ul>
<li>Get list of resource paths.</li>
</ul>
</li>
<li><code>/gazebo/resource_paths/add</code>(<a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1StringMsg__V.html">gz::msgs::StringMsg_V</a>) : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1Empty.html">gz::msgs::Empty</a><ul>
<li>Add new resource paths.</li>
</ul>
</li>
<li><code>/server_control</code>(<a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1ServerControl.html">gz::msgs::ServerControl</a>) : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1Boolean.html">gz::msgs::Boolean</a><ul>
<li>Control the simulation server.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md361"></a>
Topics</h2>
<p>The following are topics provided by the <a class="el" href="classgz_1_1sim_1_1Server.html" title="The server instantiates and controls simulation.">Server</a>. The <code>&lt;world_name&gt;</code> in the service list is the name of the simulated world.</p>
<p>List syntax: <em>topic_name : published_msg_type</em></p>
<ol type="1">
<li><code>/world/&lt;world_name&gt;/clock</code> : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1Clock.html">gz::msgs::Clock</a></li>
<li><code>/world/&lt;world_name&gt;/stats</code> : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1WorldStatistics.html">gz::msgs::WorldStatistics</a><ul>
<li>This topic is throttled to 5Hz.</li>
</ul>
</li>
<li><code>/gazebo/resource_paths</code> : <a class="elRef" href="https://gazebosim.org/api/msgs/9/classgz_1_1msgs_1_1StringMsg__V.html">gz::msgs::StringMsg_V</a><ul>
<li>Updated list of resource paths. </li>
</ul>
</li>
</ol>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a084ef7616f5af42061a7aeded5651ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a084ef7616f5af42061a7aeded5651ab0">&#9670;&nbsp;</a></span>Server()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classgz_1_1sim_1_1Server.html">Server</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classgz_1_1sim_1_1ServerConfig.html">ServerConfig</a> &amp;&#160;</td>
          <td class="paramname"><em>_config</em> = <code><a class="el" href="classgz_1_1sim_1_1ServerConfig.html">ServerConfig</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct the server using the parameters specified in a <a class="el" href="classgz_1_1sim_1_1ServerConfig.html" title="Configuration parameters for a Server. An instance of this object can be used to construct a Server w...">ServerConfig</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_config</td><td><a class="el" href="classgz_1_1sim_1_1Server.html" title="The server instantiates and controls simulation.">Server</a> configuration parameters. If this parameter is omitted, then an empty world is loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa9320a8b35b2d116b716ae4077358c6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9320a8b35b2d116b716ae4077358c6b">&#9670;&nbsp;</a></span>~Server()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classgz_1_1sim_1_1Server.html">Server</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a576d6bd6e365a6abd2db6b6d6d704fb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a576d6bd6e365a6abd2db6b6d6d704fb6">&#9670;&nbsp;</a></span>AddSystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; AddSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/memory/shared_ptr.html">std::shared_ptr</a>&lt; <a class="el" href="classgz_1_1sim_1_1System.html">System</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> to the server. The server must not be running when calling this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_system</td><td><a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to add to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the system was added successfully, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="aef95e9bc88b7b608b8d24852ba61bdff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef95e9bc88b7b608b8d24852ba61bdff">&#9670;&nbsp;</a></span>AddSystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; AddSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#a3bf4c8bbf313a71ffe6eeaf6abb6a3f8">SystemPluginPtr</a> &amp;&#160;</td>
          <td class="paramname"><em>_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a <a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> to the server. The server must not be running when calling this. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_system</td><td>system to be added </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the system was added successfully, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="a657bdb4f186c20844b1d5142cc7b6302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657bdb4f186c20844b1d5142cc7b6302">&#9670;&nbsp;</a></span>EntityByName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;<a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&gt; EntityByName </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an Entity based on a name. </p>
<p>If multiple entities with the same name exist, the first entity found will be returned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the entity to get from the specified world. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The entity, or std::nullopt if the entity or world doesn't exist. </dd></dl>

</div>
</div>
<a id="a6c36b630054b5c8b6746971070207fd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c36b630054b5c8b6746971070207fd8">&#9670;&nbsp;</a></span>EntityCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; EntityCount </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of entities on the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Entity count, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="a5078ea19560e797e61c7c654d5d49f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5078ea19560e797e61c7c654d5d49f77">&#9670;&nbsp;</a></span>HasEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HasEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified world has an entity with the provided name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the entity. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the _worldIndex is valid and the entity exists in the world. </dd></dl>

</div>
</div>
<a id="a5bac8f6ded4953caf2c28c5d14344f87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bac8f6ded4953caf2c28c5d14344f87">&#9670;&nbsp;</a></span>IterationCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;uint64_t&gt; IterationCount </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of iterations the server has executed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The current iteration count, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="a1516cd041ab3e4beb13e8ff7c45b1655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1516cd041ab3e4beb13e8ff7c45b1655">&#9670;&nbsp;</a></span>Paused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; Paused </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether a world simulation instance is paused. When paused is true, then simulation for the world is not stepping forward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the world simulation instance is paused, false if stepping forward, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="a90ee30ca04a311d697ae23ce772fe948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ee30ca04a311d697ae23ce772fe948">&#9670;&nbsp;</a></span>RequestRemoveEntity() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RequestRemoveEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacegz_1_1sim.html#ad83694d867b0e3a9446b535b5dfd208d">Entity</a>&#160;</td>
          <td class="paramname"><em>_entity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified world has an entity with the provided id and the entity was queued for deletion. Note that the entity is not removed immediately. Entity deletion happens at the end of the next (or current depending on when this function is called) simulation step. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_entity</td><td>The entity to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>Whether to recursively delete all child entities. True by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity exists in the world and it was queued for deletion. </dd></dl>

</div>
</div>
<a id="a0fddfd81ed8c8c790d2acff187ced659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fddfd81ed8c8c790d2acff187ced659">&#9670;&nbsp;</a></span>RequestRemoveEntity() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RequestRemoveEntity </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="http://en.cppreference.com/w/cpp/string/basic_string.html">std::string</a> &amp;&#160;</td>
          <td class="paramname"><em>_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>_recursive</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the specified world has an entity with the provided name and the entity was queued for deletion. Note that the entity is not removed immediately. Entity deletion happens at the end of the next (or current depending on when this function is called) simulation step. </p>
<p>If multiple entities with the same name exist, only the first entity found will be deleted. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_name</td><td>Name of the entity to delete. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_recursive</td><td>Whether to recursively delete all child entities. True by default. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the entity exists in the world and it was queued for deletion. </dd></dl>

</div>
</div>
<a id="abf20a9b198865a3d0662c275a80aa526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf20a9b198865a3d0662c275a80aa526">&#9670;&nbsp;</a></span>Run()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Run </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_blocking</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t&#160;</td>
          <td class="paramname"><em>_iterations</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_paused</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the server. By default this is a non-blocking call, which means the server runs simulation in a separate thread. Pass in true to the _blocking argument to run the server in the current thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_blocking</td><td>False to run the server in a new thread. True to run the server in the current thread. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_iterations</td><td>Number of steps to perform. A value of zero will run indefinitely. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_paused</td><td>True to start simulation in a paused state, false, to start simulation unpaused. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>In non-blocking mode, the return value is true if a thread was successfully created. In blocking mode, true will be returned if the <a class="el" href="classgz_1_1sim_1_1Server.html" title="The server instantiates and controls simulation.">Server</a> ran for the specified number of iterations or was terminated. False will always be returned if signal handlers could not be initialized, and if the server is already running. </dd></dl>

</div>
</div>
<a id="aac5c7ae68fbe26852eaf04a7fdc655fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5c7ae68fbe26852eaf04a7fdc655fe">&#9670;&nbsp;</a></span>Running() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Running </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether the server is running. The server can have zero or more simulation worlds, each of which may or may not be running. See Running(const unsigned int) to get the running status of a world. </p>
<dl class="section return"><dt>Returns</dt><dd>True if the server is running. </dd></dl>

</div>
</div>
<a id="a42e1554323d91c88e6df18655b756420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42e1554323d91c88e6df18655b756420">&#9670;&nbsp;</a></span>Running() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;bool&gt; Running </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get whether a world simulation instance is running. When running is true, then systems are being updated but simulation may or may not be stepping forward. Check the value of <a class="el" href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655" title="Get whether a world simulation instance is paused. When paused is true, then simulation for the world...">Paused()</a> to determine if a world simulation instance is stepping forward. If <a class="el" href="classgz_1_1sim_1_1Server.html#a1516cd041ab3e4beb13e8ff7c45b1655" title="Get whether a world simulation instance is paused. When paused is true, then simulation for the world...">Paused()</a> returns true, then simulation is not stepping foward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the server is running, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<a id="a3c0eb38158a7e5df85cf81fc3f198370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0eb38158a7e5df85cf81fc3f198370">&#9670;&nbsp;</a></span>RunOnce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RunOnce </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_paused</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the server once, all systems will be updated once and then this returns. This is a blocking call. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_paused</td><td>True to run the simulation in a paused state, false to run simulation unpaused. The simulation iterations will be increased by 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>False if the server was terminated before completing, not being initialized, or if the server is already running. </dd></dl>

</div>
</div>
<a id="ac1c9003abeeb903390af28413dc303d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c9003abeeb903390af28413dc303d5">&#9670;&nbsp;</a></span>SetPaused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SetPaused </td>
          <td>(</td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>_paused</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether a world simulation instance is paused. When paused is true, then simulation for the world is not stepping forward. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_paused</td><td>True to pause the world, false to unpause. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the world referenced by _worldIndex exists, false otherwise. </dd></dl>

</div>
</div>
<a id="afedf75d17864604847c76f76ae18aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afedf75d17864604847c76f76ae18aa46">&#9670;&nbsp;</a></span>SetUpdatePeriod()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SetUpdatePeriod </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::steady_clock::duration &amp;&#160;</td>
          <td class="paramname"><em>_updatePeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the update period. The update period is the wall-clock time between ECS updates. Note that this is different from the simulation update rate. ECS systems will be updated even while sim time is paused. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_updatePeriod</td><td>Duration between updates. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17a237457e57625296e6b24feb19c60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17a237457e57625296e6b24feb19c60a">&#9670;&nbsp;</a></span>Stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the server. This will stop all running simulations. </p>

</div>
</div>
<a id="a55f59172ee2a9c52d30d7e33c93c8046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f59172ee2a9c52d30d7e33c93c8046">&#9670;&nbsp;</a></span>SystemCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;size_t&gt; SystemCount </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&#160;</td>
          <td class="paramname"><em>_worldIndex</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of systems on the server. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">_worldIndex</td><td>Index of the world to query. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classgz_1_1sim_1_1System.html" title="Base class for a System.">System</a> count, or std::nullopt if _worldIndex is invalid. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="gz_2sim_2Server_8hh_source.html">gz/sim/Server.hh</a></li>
</ul>
</div><!-- contents -->
      </div>
    </main>
  </div>
</body>
